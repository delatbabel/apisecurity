<?php
/**
 * Class Server
 *
 * @author del
 */

namespace Delatbabel\ApiSecurity\Helpers;

use Delatbabel\ApiSecurity\Exceptions\SignatureException;
use Delatbabel\ApiSecurity\Generators\Key;
use Delatbabel\ApiSecurity\Generators\Nonce;

if (! function_exists('hash_equals')) {
    function hash_equals($str1, $str2) {
        if (strlen($str1) != strlen($str2)) {
            return false;
        } else {
            $res = $str1 ^ $str2;
            $ret = 0;
            for ($i = strlen($res) - 1; $i >= 0; $i--) $ret |= ord($res[$i]);
            return !$ret;
        }
    }
}

/**
 * Class Server
 *
 * Long description of class goes here.  What is this for?
 *
 * ### Example
 *
 * <code>
 * // Verify the signature.  This will thrown an exception if there is
 * // no signature or if the signature did not verify.
 * $server = new Server();
 * $server->setPublicKey($public_key);
 * try {
 *     $server->verifySignature($request_data);
 * } catch (SignatureException $e) {
 *     // fail
 * }
 * </code>
 *
 * ### TODO
 *
 * Function to validate nonces:
 *
 * * Server side nonce must have been used exactly once.
 * * Client side nonce must not have been used before.
 * * Nonces can be cached and cache can time out.
 *
 * @see Client.
 */
class Server
{
    /** @var  Key -- must contain at least the client side public key for verifying signatures */
    protected $key;

    /** @var  Nonce server side nonce */
    protected $snonce;

    /** @var  string -- shared client/server key used in HMAC calculations */
    protected $sharedKey;

    /**
     * Server constructor.
     *
     * @param Key|null $key
     */
    public function __construct(Key $key=null)
    {
        if (empty($key)) {
            $this->key = new Key();
        } else {
            $this->key = $key;
        }
    }

    /**
     * Set the public key text
     *
     * @param string $key
     * @return Server provides a fluent interface.
     */
    public function setPublicKey($key)
    {
        $this->key->setPublicKey($key);
        return $this;
    }

    /**
     * Set the shared key used in generating HMACs.
     *
     * @param $key
     * @return Client provides a fluent interface.
     */
    public function setSharedKey($key)
    {
        $this->sharedKey = $key;
        return $this;
    }

    /**
     * Generate a one time only server nonce.
     *
     * @return string
     */
    public function createNonce()
    {
        // Make a nonce
        $this->snonce = new Nonce();
        return $this->snonce->getNonce();
    }

    /**
     * Verify a signature on the request URL, the request data and the key.
     *
     * Verifying the signature requires knowledge of the client's public key, which
     * can be made public knowledge.  It does not require knowledge of the client's
     * private key, which should be known only to the client.  Each client should have
     * a unique public/private key pair.  See the Key class for generating public/
     * private key pairs.
     *
     * The request data *should* contain a nonce generated on the client and it
     * *should* contain a nonce generated on the server.  The client nonce should
     * never have been used before (generated and used once, then discarded), and
     * the server nonce should have been used exactly once before (generated by
     * the server, used once and then discarded).  These nonces ensure that the
     * request data is unique even for identical requests.
     *
     * An exception is thrown if the signature did not verify or was not present.
     *
     * @param array  $request_data
     * @return void
     * @throws SignatureException
     */
    public function verifySignature(array $request_data)
    {
        if (empty($request_data['sig'])) {
            throw new SignatureException('No signature was present on the request data');
        }

        $base64_signature = $request_data['sig'];

        // Get the data that needs to be verified.
        unset($request_data['sig']);
        $data_to_verify = http_build_query($request_data);

        // Verify the signature
        $verify = $this->key->verify($data_to_verify, $base64_signature);
        if (! $verify) {
            throw new SignatureException('The signature on the request data did not verify');
        }
    }

    /**
     * Verify a HMAC for a request.
     *
     * Verifying a HMAC for a request requires knowledge of a key that is shared between
     * the client and server and should not be disclosed to any third party.
     *
     * The request data *should* contain a nonce generated on the client and it
     * *should* contain a nonce generated on the server.  The client nonce should
     * never have been used before (generated and used once, then discarded), and
     * the server nonce should have been used exactly once before (generated by
     * the server, used once and then discarded).  These nonces ensure that the
     * request data is unique even for identical requests.
     *
     * An exception is thrown if the signature did not verify or was not present.
     *
     * @param array $request_data
     * @return void
     * @throws SignatureException
     */
    public function verifyHMAC(array $request_data)
    {
        if (empty($request_data['hmac'])) {
            throw new SignatureException('No HMAC was present on the request data');
        }

        // Get the data that needs to be verified.
        $supplied_hmac = $request_data['hmac'];
        unset($request_data['hmac']);
        $data_to_verify = http_build_query($request_data);

        // Create the base64 encoded copy of the HMAC.
        $calculated_hmac = base64_encode(hash_hmac("sha256", $data_to_verify, $this->sharedKey, true));

        // Verify the HMAC
        $verify = hash_equals($calculated_hmac, $supplied_hmac);
        if (! $verify) {
            throw new SignatureException('The HMAC on the request data did not verify');
        }
    }
}
